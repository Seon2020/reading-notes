# Linked Lists

## Linked Lists
- Each Node references the next Node in the link.
- Two tpes of linked lists: Singly and Doubly
- Linked List: A data structure that contains nodes that links/points to the next node in the list.
- Nodes: the individual items/links that live in a linked list. Each node contains the data for each link.
- Head: reference type of type Node to the first node in a linked list.
- While traversing a linked list, you are not able to use a foreach or for loop.
- The best way to approach a traversal is through the use of a while() loop.
- If we accidentally end up trying to traverse on a node that is null, a NullReferenceException gets thrown and our program will crash/end.
- Pseudo code for an includes:
```
ALGORTIHM Includes (value)
		// INPUT <-- integer value
		// OUTPUT <-- boolean
			
			Current <-- Head

			WHILE Current is not NULL
				IF Current.Value is equal to value
					return TRUE

				Current <-- Current.Next

			return FALSE
```
- Big O of time for Includes would be O(n). This is because, at its worse case, the node we are looking for will be the very last node in the linked list. n represents the number of nodes in the linked list.
- Big O of space for Includes would be O(1). This is because there is no additional space being used than what is already given to us with the linked list input.
- Pseudo code for an Add method on a Linked list:
```
ALGORITHM Add(newNode)
		// INPUT <-- Node to add 
		// OUTPUT<-- No output

			Current <-- Head
			newNode.Next <-- Head
			Head <-- newNode
			Current <-- Head
 ```
 - IMPORTANT: Regardless of the number of Nodes that this linked list has, it will always be a O(1) time and space because it takes the same amount of time to add a new node to the beginning of the list, and no additional resources are being used.
 - Pseudo code for an AddBefore method in a linked list:
```
ALGORITHM AddBefore(newNode, existingNode)
		// INPUT <-- New Node, Existing Node
		// OUTPUT <-- No Output

			Current <-- Head

			while Current.Next is not equal to NULL
				if Current.Next.Value is equal to existingNode.Value
					newNode.Next <-- existingNode
					Current.Next <-- newNode

				Current <-- Current.Next;		
```
- Time efficiency for this example: O(n) because we could be inserting the new node, worst case scenario, at the end. With n being the number of nodes possible, we would therefore have O(n) time efficiency.
- Space efficiency for this example: O(1) because, like before, no additional space is being used allocated outside of what is given to us on the input.
- Pseudo code for a method to print out all nodes in a linked list:
```
ALGORITHM Print()
		// INPUT <-- None
		// OUTPUT <-- string to console

			Current <-- Head

			while Current.Next is not equal to NULL
				OUTPUT <-- "Current.Value --> "
				Current <-- Current.Next

			OUTPUT <-- "Current.Value --> NULL"
```
## What’s a Linked List, Anyway pt1

## What’s a Linked List, Anyway pt2
